#include "GraphexiaRenderer.hpp"

// Autogenerated with xmake and sokol-shdc
#include "Core.hpp"
#include "graphvtx.glsl.h"

// FIXME: Check if failed to create shader and pipeline
void GraphexiaRenderer::Init() {
    sgp_pipeline_desc vPipeline{};
    this->vtxShader = sg_make_shader(graphexia_graphvtx_shader_desc(sg_query_backend()));
    vPipeline.shader = this->vtxShader;
    vPipeline.blend_mode = SGP_BLENDMODE_BLEND;
    vPipeline.color_format = SG_PIXELFORMAT_RGBA8;
    vPipeline.depth_format = SG_PIXELFORMAT_DEPTH_STENCIL;
    vPipeline.primitive_type = SG_PRIMITIVETYPE_TRIANGLES;
    vPipeline.has_vs_color = true;
    vPipeline.sample_count = 1;
    this->vtxPipeline = sgp_make_pipeline(&vPipeline);
}

void GraphexiaRenderer::RenderView(const gpx::GraphView& view, const SelectionType selectionType, const usize selectedId, const f32x2 worldMousePosition) {
    const gpx::Graph& graph = view.GetGraph();
    const std::vector<gpx::VertexView>& vertexViews = view.Views();
    const std::vector<gpx::Edge>& edges = graph.Edges();

    bool vertexSelected = (selectionType & SelectionType::VertexSelected) == SelectionType::VertexSelected;

    sgp_set_color(1, 1, 1, 1);
    for (const gpx::Edge& edge : edges) {
        const gpx::VertexView& from = vertexViews[edge.fromId]; 
        const gpx::VertexView& to = vertexViews[edge.toId]; 

        if(edge.fromId != edge.toId) {
            sgp_draw_line(from.position.x, from.position.y, to.position.x, to.position.y);
            continue;
        }

        //DrawCircleLines(from.position.x - 3, from.position.y - 3, 7, {255, 255, 255, 255});
    }

    sgp_set_color(.1, .9, .2, 1);
    if(selectedId != gpx::Graph::NoId && (selectionType & SelectionType::VertexDrawingEdge) == SelectionType::VertexDrawingEdge) {
        const gpx::VertexView& vtxView = view.Views()[selectedId];
        sgp_draw_line(vtxView.position.x, vtxView.position.y, worldMousePosition.x, worldMousePosition.y);
    }

    sgp_set_pipeline(this->vtxPipeline);
    sgp_set_color(1, 1, 1, 1);
    usize v = 0;
    for (const gpx::VertexView& vertex : vertexViews) {
        if(v++ == selectedId && vertexSelected) {
            continue;
        }

        sgp_draw_filled_rect(vertex.position.x - vertex.size, vertex.position.y - vertex.size, 2*vertex.size, 2*vertex.size);
    }

    if(selectedId != gpx::Graph::NoId && vertexSelected) {
        sgp_set_color(.1, .9, .2, 1);
        if((selectionType & SelectionType::DeletionRequest) == SelectionType::DeletionRequest) {
            sgp_set_color(.9, .1, .2, 1);
        }

        const gpx::VertexView& vertex = vertexViews[selectedId];
        sgp_draw_filled_rect(vertex.position.x - vertex.size, vertex.position.y - vertex.size, 2*vertex.size, 2*vertex.size);
    }

    sgp_reset_pipeline();    
}
